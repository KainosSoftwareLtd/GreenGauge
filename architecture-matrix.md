

| Section | Description |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Main areas                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                                                                                                                                       1 Point                                                                                                                                                        | 3 Points |                                                                                                      5 Points                                                                                                      |
|---------|:-----------:|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|:--------:|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| Principles | The way you design, build and operate software is influenced by your architecture principles and approach.The following factors can affect how much carbon your software emits:<ul><li>using public cloud services</li><li>choosing managed services</li><li>adopting a certain architecture style</li></ul> |                                                                                                                                                                                                                                                                                                                                                                                                 **Green Software Principles**: Considering how to save energy, use hardware effectively and be aware of carbon emissions.<br/><br/>**Cloud selection guidance**: Defining the preference by which cloud service offerings are considered in declining order of importance: SaaS->PaaS->IaaS                                                                                                                                                                                                                                                                                                                                                                                                 |                                        **Green Software Principles**: The organisation is partially aware of the principles but they are not being yet applied<br/><br/>**Cloud Selection Guidance**: People are free to select what they think is right and works best for them.                                         |     **Green Software Principles**: The organisation has defined clear principles though is is not clear how well this has cascaded across the organisation.<br/><br/>**Cloud Selection Guidance**: Preference is given the PaaS and provider managed offerings over bespoke.| **Green Software Principles**: Clear principles defined with clear adoption across the organisation.<br/><br/>**Cloud Selection Guidance**: Preference is given the SaaS solutions with IaaS being the least preferred. |
| Design | Design your software with energy and hardware efficiency in mind.<br/><br/>This helps to optimise carbon impact both now and in the future.<br/><br/>Adopt modular, decoupled architectures to enable targeted changes or quick improvements. |                                                                                                                                                                                                                                                                                                                                                                                        **Architecture Guidance**: How do you assist people in architecting solutions aligned to green software principles? Do golden paths exist?<br/><br/>**Pattern Library**: Where can people discover previously implemented patterns or versions of good for solutions aligned with green software principles?                                                                                                                                                                                                                                                                                                                                                                                         |                                               **Architecture Guidance**: People draw on their own experience and what they can find on the internet to design what they think is right.<br/><br/>**Pattern Library**: Patterns are shared across informal employee networks                                               | **Architecture Guidance**: Guidance exists for how to deploy commonly utilised components in an energy/hardware efficient manner e.g. 12-factor apps.<br/><br/>**Pattern Library**: Patterns are stored/maintained by the architecture community. | **Architecture Guidance**: There are guidelines based on scenarios that show the best way and the ideal steps to achieve results in a way that saves energy and hardware.<br/><br/>**Pattern Library**: A pattern library is actively contributed to and maintained across the organisation. |
| Storage | The way you classify, store, and access your data is important.<br/><br/>Adjust service levels to match the data access profile and make sure you only backup data that is essential for your business.<br/><br/>The less data you store, the less impact you have. Thinking of data as limited and not infinite, is the attitude we should have. |                                                                                                                                                                                                                                                                                               **RRD**: To combat the risk of ever growing data, a robust **review, retention and disposal** policy is required. How well is this implemented/adopted across your business today? Does this apply to all data types? What about monitoring data, log data or audit data?<br/><br/>**Storage profiling**: We use the most appropriate type of storage required and don't just always default to the fastest available.<br/><br/>**Compression**: Do you always make of this feature when available?                                                                                                                                                                                                                                                                                                | **RRD**: We have no RRD policy in place, our data volumes tend to grow and data is removed only on an ad-hoc basis.<br/><br/>**Storage profiling**: We tend to use the fast storage as it will always meet our needs.<br/><br/>**Compression**: We turn it on when the service offering makes a compression feature available. | **RRD**: RRD policy is defined and proactively applied to new services being built.<br/><br/>**Storage profiling**: We use tiered storage to move less frequently accessed storage to slower (and cheaper) mediums.<br/><br/>**Compression**: We embed data compression into our solutions to ensure all data in transit is encrypted. | **RRD**: RRD policy is defined and proactively applied to new and existing services.<br/><br/>**Storage profiling**: We use tiered storage to dynamically move data across different mediums and match storage performance profiles to non-functional requirements.<br/><br/>**Compression**: We embed data compression into our solutions to ensure all data in transit and at rest is encrypted. |
| Compute | You should choose the best form of compute to boost performance and minimise impact for your workload. Some ways to do this are: using more parallel processes, speeding up computation with GPUs, or switching to ARM-based systems that may use less energy. You can also start with the simple step of adjusting your infrastructure to fit your needs. | **Hardware efficiency**: Choosing the optimal instruction set or hardware capabilities relative to your workload can improve efficiency; don't just default to x86 everytime.<br/><br/>**Choosing the correct size**: Choosing the service family and tier of your service that best suits its performance needs. You should aim to use your resources efficiently and avoid wasting them. You need to find the optimal balance between the two and reducing unnecessary or low-use resources.<br/><br/>**Async Patterns**: Don't default to microservices and always consider the optimal architecture relative to your workload. Where possible you should prioritise event-driven patterns as they enable 'scale to zero' use-cases which negate some of the need for overlapping controls like intelligent scheduling.<br/><br/>**Intelligent scheduling**: The ability to schedule compute resources to be available only when needed or to execute based on the availability of low-carbon energy sources e.g. running a batch job when the energy mix within a region favours renewable power. | **Hardware Efficiency**: Our default is x86 and we haven't needed to look at anything else.<br/><br/>**Choosing the correct size**: We plan capacity in advance and always build some room for growth into our solution.<br/><br/>**Async Patterns**: We deploy long-lived services such as microservices.<br/><br/>**Intelligent Scheduling**: Our services remain running all the time, though sometimes we turn some environments off to save money. | **Hardware Efficiency**: Most workloads align with our default of x86, though we do make use of GPU/ARM for specific workloads.<br/><br/>**Choosing the right size**: We continuously adjust the size of our infrastructure centrally based on cloud provider recommendations for example, from Azure Advisor.<br/><br/>**Async Patterns**: Whilst we mostly deploy long-lived services such as microservices we also make use of event-driven architectures.<br/><br/>**Intelligent Scheduling**: We have automated scheduling to turn things off when they aren't used to save resources. | **Hardware Efficiency**: We have no default. We actively require consideration alternative instruction sets to boost performance.<br/><br/>**Choosing the right size**: Our teams are encouraged and rewarded for using the right size for their infrastructure.<br/><br/>**Async Patterns**: Event-driven architectures are preferred and actively considered for all new service delivery.<br/><br/>**Intelligent Scheduling**: We schedule our workloads based on the availability of low-carbon energy sources. |
| Networking | Optimise data transmission between software components to significantly influence efficiency and energy use. For example, the shorter the distance and fewer the components, the less the impact. Explore the use of things like GraphQL to reduce transmission of unneeded data or leverage content-delivery networks to deliver services closer to your end user. |                                                                                                                                                                                                                                                                   **Number of Requests**: Each request has an overhead including the TLS handshake; the more that can be done to reduce the number of requests in addition to payload size can improve energy efficiency.<br/><br/>**Bandwidth**: Minimising data transmission through use of compression and service optimisation to reduce unneeded data exchange.<br/><br/>**Local POP**: The more proximate the service to consumers, the lesser the transmission distance and energy costs.<br/><br/>**Edge**: How can you minimise data transmission through pre-processing?                                                                                                                                                                                                                                                                    | **Number of Requests**: We are aware of how many requests are made but we don't make many efforts to reduce them.<br/><br/>**Bandwidth**: We are aware of bandwidth cost but we don't make many efforts to reduce it.<br/><br/>**Local POP**: Services delivered centrally for everyone.<br/><br/>**Edge**: We transmit the raw data to be processed centrally. | **Number of Requests**: Aware of how many requests are made and some efforts to optimise the number.<br/><br/>**Bandwidth**: Aware of bandwidth cost and turning on compression where possible to reduce volume.<br/><br/>**Local POP**: Most services delivered centrally but we make use of a CDN for commonly accessed assets.<br/><br/>**Edge**: We try to clean-up the raw data on the users device prior to transmitting centrally. | **Number of Requests**: We have actively adjusted our architecture to reduce the number of requests and data transmitted e.g. adoption of GraphQL.<br/><br/> **Bandwidth**: Active efforts to prioritise and reduce things like page weights.<br/><br/>**Local POP**: We make use of a CDN and prioritise efforts to reduce things like server response time.<br/><br/>**Edge**: We clean-up the data on the users device and at each transmission hop to minimise onward transmission costs. | 
| Non-functional requirements | Non-functional requirements can greatly impact how efficient our solutions can be. For example, meeting a 99% vs a 99.9% availability target can dramatically increase environment impact owing to the additional infrastructure required to support this. Challenging assumptions behind non-functional requirements is one of the quickest ways to identify quick wins with the business, for example, do you really need access to the service on weekends? |**Service Availability**: Do you really need such a high availability target? <br/><br/> **Performance**: What is tolerable/noticeable to users vs arbitrary targets?<br/><br/>**Backup**: Do you need to backup everything? Dp you need to replicate your backups across multiple different locations?<br/><br/>**AI Model Accuracy**: How much is 'good enough' compared with striving for perfect?<br/><br/>**Sustainability NFRs**: To augment the existing NFRs| **Service Availability**: We have a really ambitious target set by the business because our service is so important.<br/><br/>**Performance**: Performance targets are set by the architects based on their experience.<br/><br/>**Backup**: We tend to back everything up so we can quickly recover the service and we may have multiple copies of each backup.<br/><br/>**AI Model Accuracy**: We tend to use the most accurate models because they give the best results.<br/><br/>**Sustainability NFRs**: We don't have any explicitly around this | **Service Availability**: We have a really ambitious target set by the business that we've challenged.<br/><br/>**Performance**: Performance targets are set by the architects based on their experience and are actively tested through automation.<br/><br/>**Backup**: We tend to backup all application data so we can quickly recover the service.<br/><br/>**AI Model Accuracy**: We trade-off model accuracy against performance and resource usage when a new service is created.<br/><br/>**Sustainability NFRs**: We have established some proxies for sustainability in our existing NFRs. | **Service Availability**: We have a really ambitious target set by the business that we've challenged and successfully reduced or put mitigations in place to offset.<br/><br/>**Performance**: Performance targets are informed through user feedback using production telemetry and are actively tested through automation.<br/><br/>**Backup**: We only backup business critical data.<br/><br/>**AI Model Accuracy**: We proactively trade-off model accuracy vs performance/resource usage through the lifecycle of a service e.g. as a better/new/more-efficient model becomes available we switch to it.<br/><br/>**Sustainability NFRs**: We have an explicit set of sustainability focused NFRs.|
| Governance | The way technology governance guides architecture and technology principles can have a big influence on how things are done and what results are achieved. For instance, not only should you have some green software principles, but they need to be implemented and monitored by a green software governance framework. | **Decision Making**: What rules and processes do you use for making technology choices?<br/><br/>**Evaluation**: Which weighting do you apply to sustainability functional and non-functional requirements when making decisions? Do yoy apply a stronger weighting for vendors whom report on their own carbon impact and less for those that don't? | **Decision Making**: We decide based on each situation and with the input of our peers. We try our best, but the views are subjective of the people involved.<br/><br/>**Evaluation**: Some consideration given to alternative options but these can prioritise functional rather than non-functional fit. | **Decision Making**: New service delivery and change controls require consideration of carbon/environmental impact and the risks involved.<br/><br/>**Evaluation**: Consideration of alternatives spans functional and non-functional concerns. | **Decision Making**: We use a strict method for delivering new services and making changes that requires us to base our decisions on data.<br/><br/>**Evaluation**: Consideration of alternatives spans functional and non-functional concerns with a clear framework in place. |
| Scalability | Increasing or decreasing capacity gracefully relative to demand is one of the key challenges of modern technology platforms which often offer consumption based pricing. Ultimately, when there is no-demand you'll want to scale in/down as you want to minimise resource usage and cost when there is no demand. Using event-driven architectures you can do just this with ‘scale to zero’ patterns. | **Scaling Approach**: Scaling is not a one size fits all; scaling on demand based on custom metrics is normally more efficient than scheduling services to scale during fixed windows.<br/><br/>**Carbon Shifting**: Determining in which locations you scale or the intelligent shifting of workloads based on the availability of lower carbon energy sources.<br/><br/>**Caching**: Caching should be embedded through the application stack to reduce unnecessary requests and demands being placed on the system.<br/><br/>**Utilisation**: Utilisation, in this context, is indicative of energy proportionality; it is the relationship between power consumed by a device and the rate at which useful work is done. You should aim for high utilisation for your systems to be the most efficient. | **Scaling Approach**: We either don't scale or schedule it in advance based on known seasonality.<br/><br/>**Carbon Shifting**: We don't do this, we tend to operate in one region.<br/><br/>**Caching**: We do the basics like in-memory caching and utilising local storage for caching frontend static assets like images.<br/><br/>**Utilisation**: We design our workloads to accommodate expected peaks in demand with sufficient capacity to safely weather this. Outside of peaks we can have low-rates of utilisation. | **Scaling Approach**: We are able to quickly scale based on observed demand to minimise wasted resources.<br/><br/>**Carbon Shifting**: Whilst we have multiple regions we tend to site services based on factors other than local carbon intensity e.g. compliance with local laws.<br/><br/>**Caching**: Beyond local caching we make use of content delivery networks to distribute status assets from local points of presence (POP) minimising the network roundtrip and latency.<br/><br/>**Utilisation**: We try to achieve maximum utilisation by dynamically scaling to meet demand. We do keep some flex capacity in the system to accommodate for scale-out time/delays. | **Scaling Approach**: We are able to quickly scale based on observed demand to minimise wasted resources.<br/><br/>**Carbon Shifting**: We have multiple regions and actively shift/balance workloads in favour of the prevailing carbon intensity within those regions.<br/><br/>**Caching**: We make use of application level caching.<br/><br/>**Utilisation**: We design our workloads maximise utilisation by dynamically scaling to meet demand. We optimise our systems for rapid scaling to minimise the need for extra capacity. |
| Development | The environmental impact of our software depends on how we choose to develop it throughout all its different stages. For example, if our development approach requires each developer to have a new, high-specification device to create a development environment or troubleshoot problems locally, our impact can be much greater than if using cloud development environments. | **Language**: Choice of programming language can impact upon energy efficiency with some studies showing that interpreted languages, such as Python, are significantly more impactful than compiled languages, such as C. <br/><br/>**Developer environments**: How well can your developers test/validate changes on their local machines prior to committing code? The sooner they can fail and the more easily they can do this without requiring high-powered workstations the better.<br/><br/>**Build environments**: How best can we catch failure at the earliest possible point to fail a build? | **Language**: You have a default language that you always use when building a new service.<br/><br/>**Developer Environments**: Depending on the resources of your local workstation, you may be able to create a representative test environment validate changes locally.<br/><br/>**Build Environments**: All changes are built and progressed through long-lived test environments until a release is ready or a failure is noted. | **Language**: You have several preferred languages and you pick the best of these relative to your teams capability and the problem domain.<br/><br/>**Developer environments**: Clear processes supporting developers validating changes in locally provisioned test environments prior to committing code. This requires developers to have a high specification laptop.<br/><br/>**Build environments**: All changes are built and progressed through short-lived on-demand test environments. | **Language**: You pick the most efficient language relative to the problem domain.<br/><br/>**Developer environments**: Developers can validate changes they are making using 'just-in-time' cloud workstations and personal environments.<br/><br/>**Build environments**: All changes are built and progressed through short-lived on-demand test environments which are created on-demand. Test tolerances actively break the build where quality thresholds are not met.


